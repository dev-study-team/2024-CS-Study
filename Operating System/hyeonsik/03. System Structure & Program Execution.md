
# 1️⃣ 컴퓨터 시스템의 구조 (입출력)
- 컴퓨터 동작 흐름 : 입출력
    - 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, (input)
    - 그 결과를 외부 장치로 다시 내보내는 방식으로 업무를 처리함 (output)
    - 예. 키보드로부터 입력(input)을 받아서, 그 결과를 모니터로 출력(output)
- 커널
    - 운영체제의 가장 핵심적인 부분
    - 항상 메모리에 상주하며 각종 자원들을 관리함
- 컨트롤러
    - 각 하드웨어를 제어하는 작은 CPU
    - 각 하드웨어 장치에는 컨트롤러라는 것이 붙어있음
    - 컨트롤러는 로컬 버퍼(작은 메모리)를 통해 연산을 위한 데이터 관리
        - 컨트롤러는 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
        - 디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬버퍼에 데이터가 임시로 저장된 후 메모리이 전달됨
        - 컨트롤러가 장치에서 데이터를 읽어 로컬버퍼에 저장함
    - 컨트롤러는 작업이 완료되면 인터럽트를 발생시켜 CPU에 보고
        - 인터럽트: 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법
- 인터럽트 확인 메커니즘
    - 기본적으로 CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어와 수행함
    - CPU 옆에는 인터럽트 라인이 존재하며 이를 통해 인터럽트 발생여부를 확인할 수 있음
    - CPU는 명령 하나를 완료할 때마다 인터럽트가 발생하였는지 확인
    - 인터럽트가 발생한 경우, 인터럽트를 처리하고 그 이후에 다시 다음 명령을 수행하게 됨

## CPU 연산과 I/O 연산
- 연산 = CPU가 작업을 처리하고 있다는 뜻
- 입출력 장치들의 I/O 연산은 입출력 컨트롤러가 담당


# 2️⃣ 인터럽트
- 컨
- 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일이 코드화되어 보관되어있음
- 운영체제는 각종 하드웨어 및 소프트웨어 자원 관리 뿐 아니라 사용자 프로그램에 필요한 서비스도 제공
- 운영체제가 해야 할 일들을 운영체제의 개발자가 미리 프로그래밍해서 커널 내에 포함시켜 둠
- 그 중 한가지가 인터럽트 처리 루틴이다.
    - 운영체제 커널 내에 있음
    - 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의하고 있음
    - 인터럽트 핸들러라고도 부름
- 인터럽트 벡터
    - 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조
- 인터럽트 발생시 순서
    - 장치의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달
        - 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해두는 일
    - 하던 작업을 멈추고 인터럽트 벡터를 참조해 처리코드를 찾음
    - 인터럽트 처리 루틴을 수행
    - 인터럽트 처리 후, 중단되어있던 기존 작업을 계속해서 수행
        - 인터럽트 처리 전, 하던 작업의 위치를 저장해두어야 돌아갈 수 있으며 이러한 장소를 운영체제는 별도로 가지고 있음

## 📌 인터럽트 종류
- 하드웨어 인터럽트
    - 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
    - 통상적으로 인터럽트는 하드웨어 인터럽트를 의미
- 소프트웨어 인터럽트
    - Trap 이라는 용어로 주로 불림
    - Exception과 SystemCall이 소프트웨어 인터럽트의 예
    - 예외상황은 사용자 프로그램이 비정상적인 작업(0으로 나누는 연산 등)을 할 때 발생

## 📌 시스템 콜
- 사용자 프로그램이 운영체제에 서비스를 요청하는 방법
    - 운영체제 커널에 있는 코드를 활용하고 싶을 때, 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행
    - 커널 이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출
    - 함수 호출을 위해 프로그램은 인터럽트 라인에 인터럽트를 세팅함


## 📌 인터럽트 핸들링
- 인터럽트가 발생한 경우 처리해야 할 일의 절차를 의미

순서
1. 사용자 프로그램이 실행되고 있을 때, 인터럽트가 발생하면 프로그램의 현재 상태를 먼저 저장
    1. 현재 CPU에서 실행 중인 명령의 메모리 주소
    2. 및 몇가지 부가적인 정보들
    3. CPU는 명령을 수행할 때, 임시 기억장치인 레지스터를 활용하는데 인터럽트를 수행하게되면 기존 값들이 지워짐. 복귀했을 때 이러한 값을 활용할 수 있게 상태를 저장해야함

## 📌 PCB (Process Control Block)
![](Pasted%20image%2020240228201155.png)
- 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 저장
    - 프로그램이 실행중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등이 저장됨

오늘날의 컴퓨터에서 운영체제는 인ㅌ럽트가 발생할 때에만 실행된다.
시스템이 부팅 후 정상상태에 머무르게 되면 CPU가 항상 사용자 프로그램에 의해 사용되며, 운영체제는 단지 인터럽트가 발생했을 때에만 잠깐 CPU의 제어권을 획득할 수 있기 때문이다. 
-> 타이머에 의해 인터럽트가 발생하는 경우
-> 입출력 요청을 위해 시스템 콜을 하는 경우


# 3️⃣ 입출력 구조
- 입출력이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것을 말함
- 동기식 입출력과 비동기식 입출력이 있음

## 📌 동기식 I/O
- 어떤 프로그램이 입출력 요청을 했을 때, 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식
- 입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다림
- 입출력이 완료되어 인터럽를 통해 그 사실이 전달된 후에야 CPU 제어권이 프로그램에게 넘어가 다음 명령을 수행할 수 있게됨
- CPU는 입출력 연산이 끝날때까지 인터럽트를 기다리며 자원을 낭비하게 됨
- 일반적인 경우 입출력시도시, 입출력이 완료될때까지 CPU를 다른 프로그램에 이양하여 낭비를 막는다.
    - 봉 쇄 상태 (blocked state)로 전환하여, 입출력이 완료될 때까지 차례가 돌아오지 못하게 함
- 다수의 입출력이 동시에 요청되는 경우
    - 동기식 입출력에서 입출력 요청의 동기화를 위해 장치별로 큐를 두어 요청한 순서대로 처리함
    - 큐에 있는 순서대로 처리함으로써 동기화 문제를 해결할 수 있음
    - 요청을 모으고 처리순서를 바꾸어 입출력 효율성을 높일 수 있으며, 이를 위해선 별도의 동기화 보장 방안이 마련되야 함

## 📌 비동기식 I/O
- 입출력 연산 요청 후 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식
- 입출력 연산 요청 이후, 해당 데이터와 상관 없이 수행할 수 있는 일이 있다면 그 작업을 먼저 수행
- 이후 입출력이 완료된 후에 기존 작업을 이어 가게 됨
- 예. 디스크 쓰기 요청에 경우, 작업이 완료되지 않아도 다음 명령을 수행할 수 있으므로 비동기에 적합

## 📌 동기식 비동기식 I/O 비교그림
![](Pasted%20image%2020240228194449.png)


# 4️⃣ DMA (Direct Memory Access)
- CPU 이외에 메모리 접근이 가능한 장치
- 일종의 컨트롤러로서, CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할
    - 로컬버퍼에서 메모리로 읽어오는 작업을 CPU대신 행함
    - CPU는 원래 하던 작업을 멈추고 인터럽트를 처리할 필요가 없어짐
    - CPU 인터럽트 발생 빈도를 줄여 효율적으로 CPU를 관리하고 빠르게 입출력 연산을 수행할 수 있게 함
- DMA는 바이트(byte)단위가 아니라 블록(block)이라는 큰 단위로 데이터를 메모리로 읽어옴
- 메모리로 데이터를 모두 옮기면 인터럽트를 발생시킴


# 5️⃣ 메모리(저장장치) 계층 구조
- 저장장치는 빠른 저장장치보다 느린 저장장치까지 단계적인 계층 구조로 이루어짐
- 접근 속도가 빠른 장치는 가격이 비싸 작은 용량을 가짐
- 이를 효율적으로 활용하기 위해, 당장 필요한 정보는 빠른 장치에, 그렇지 않은 정보는 느린 장치에 보관

![](Pasted%20image%2020240228194837.png)

## 📌 캐싱  기법
- 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
- 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충
- 빠른 저장장치에서 빈번히 사용될 정보를 저장하면 필요한 정보를 빠른 저장장치에서 곧바로 찾을 수 있는 경우가 많아져 전체적인 선응이 향상됨
- 캐싱이 효과를 볼 수 있는 이유는 컴퓨터 내의 데이터나 프로그램은 보통 일부분만이 집중적으로 사용되기 때문


# 6️⃣ 보안
## 📌 하드웨어 보안
- 다중 프로그래밍 환경에서 프로그램 간의 충돌을 막기 위해 하드웨어에 대한 각종 보안 기법이 필요함
- 운영체제는 기본적으로 커널모드와 사용자모드를 지원함
    - CPU 내부에 현재 모드에 대한 정보가 들어있는 modebit가 있음
    - CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 0인경우에만 실행
    - 보안이 필요한 모든 명령을 '특권명령' 이라고 부르며, 커널모드에서만 가능
- 커널모드 (modebit 0)
    - 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드
    - 모든 종류의 명령을 다 실행할 수 있음
    - 시스템에 중요한 영향을 미치는 연산은 커널모드에서만 실행가능
    - 사용자 프로그램이 하드웨어 접근 등 보안이 필요한 중요한 명령을 수행해야 할 경우 시스템콜을 통해 인터럽트를 발생시킴
        - CPU 제어권은 운영체제에게 넘어가며, 인터럽트가 발생할 때 모드비트는 자동으로 0으로 세팅됨
- 사용자모드 (modebit 1)
    - 일반 사용자 프로그램이 실행되며 제한적인 명령만 수행할 수 있음
    - 운영체제가 사용자프로그램에게 CPU 제어권을 넘길때 모드비트를 1로 세팅함



## 📌 메모리 보안
- 메모리 보안이 필요한 이유
    - 여러 프로그램이 메모리에 동시에 올라가 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있어 보안이 필요함
    - 적어도 인터럽트 벡터와 인터럽트 처리루틴이 있는 곳은 각별한 보안이 필요
    - 사용자 프로그램이 인터럽트 처리루틴을 접근하거나 변경할 수 있을 경우 특권명령이 변조될 수 있기 때문
- 방법 (프로그램이 메모리에 연속적으로 위치하는 경우에)
    - 2개의 레지스터를 이용해 프로그램이 접근하려는 메모리 부분이 합법적인 체크하여 메모리 보호
        - 기준 레지스터 (base register)
        - 한계 레지스터 (limit register)
        - 두 레지스터 값 설정은 특권명령으로, 사용자 프로그램이 직접 변경할 수 없음
    - 기준 레지스터는 프로그램이 수행되는 동안 그 프로그램이 접근할 수 있는 가장 작은 메모리 주소를 보관
    - 한계 레지스터는 프로그램이 수행되는 동안 그 프로그램이 접근할 수 있는 가장 큰 메모리 주소를 보관
    - 사용자 프로그램은 기준레지스터값~한계레지스터값의 메모리에만 접근할 수 있음
    - 다른 메모리에 접근할 경우 Exception이 발생하며, 운영체제는 해당 프로그램을 강제 종료 시킴
- 메모리 접근 연산은 특권명령이 아님
    - 단, 커널모드의 경우 어느 메모리든 자유롭게 접근 가능


## 📌 Timer (CPU 보호)
- 사용자 프로그램의 CPU 독점을 막기위해 Timer라는 하드웨어를 사용
- 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 사용자 프로그램의 최대 사용시간을 제한하며, 운영체제가 CPU의 제어권을 획득할 수 있게함
- 타이머 동작
    - 타이머는 일정한 시간 단위로 세팅됨
        - 타이머값 세팅 명령을 LoadTimer라고 하며 특권명령에 속함
    - 매 클럭 틱마다 1씩 감소
    - 타이머가 0이 되는 순간 인터럽트가 발생
- 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용됨


# 7️⃣ 프로그램의 주소영역
![](Pasted%20image%2020240216142442.png)
- 코드, 데이터, 스택 영역으로 구분됨
- 코드 영역에는 작성한 프로그램의 코드가 기계어 명령 형태로 변환되어 저장
- 데이터 영역은 전역 변수 등 프로그램이 사용하는 데이터를 저장
- 스택 영역은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는데 사용
    - 단, 인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 PCB(프로세스 제어블록)에 저장됨
    - 힙: 프로그래머가 필요할 때 사용하는 공간


## 📌 프로그램의 실행
- 프로그램마다 독자적으로 존재하는 이러한 주소 공간을 우리는 가상메모리 라고 부름
- 이는 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소공간을 가지기 때문에 지칭하는 용어

## 📌 운영체제의 주소영역
- 운영체제도 하나의 프로그램이므로 커널역시 코드, 데이터, 스택의 주소 공간 구성을 가지고 있음
- 커널의 코드 영역
    - 자원 관리 코드, 사용자에게 인터페이스를 제공하기 위한 코드
    - 시스템 콜 및 인터럽트를 처리하기 위한 부분
- 커널의 데이터 영역
    - 각종 자원을 관리하기 위한 자료구조가 저장 (CPU, 메모리,  프로세스)
    - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용정보 등을 유지하기 위한 자료구조인 PCB가 위치함
- 커널의 스택 영역
    - 함수호출 시의 복귀 주소를 저장하기 위한 용도로 사용됨
    - 커널의 스택은 현재 수행중인 프로세스마다 별도의 스택을 두어 관리함
    - 시스템콜 내부에서 다른 함수를 호출하는 경우, 그 복귀 주소를 일관성있게 관리하기 위해 별도로 관리

# 8️⃣ 컴퓨터 시스템의 작동
![](Pasted%20image%2020240228195714.png)
- CPU가 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행함
- CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터(ProgramCounter: PC)라고 부름
- 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 됨

## 📌 사용자 프로그램 실행 예시
![](Pasted%20image%2020240228000312.png)
- 사용자 모드에서 실행 상태 (User Mode Running)
    - 자신의 주소 공간에 정의된 코드를 실행하는 상태
- 커널모드에서의 실행 상태 (Kernel Mode Running)
    - 커널의 시스템 콜 함수를 실행하는 상태
- 모두 '프로세스 A가 실행 상태에 있다'라고 말한다.
    - 커널은 A의 요청에 의해 일을 대행해 주고 있는 것 뿐임
    - 'A가 커널 모드에서 실행 중'





# 함수의 종류
- 사용자 정의 함수
    - 프로그래머 본인이 직접 작성한 함수
    - 프로세스의 주소 공간에 포함되며, 함수호출 시 자신의 주소 공간에 있는 스택을 사용
- 라이브러리 함수
    - 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 경우
    - 프로세스의 주소 공간에 포함되며, 함수호출 시 자신의 주소 공간에 있는 스택을 사용
- 커널 함수
    - 운영체제 커널의 코드에 정의된 함수
    - 시스템 콜 함수, 인터럽트 처리 함수가 존재함
    - 커널의 주소 공간에 코드가 정의됨





---




# 메모

4장 초반에 관련 내용을 정리함


Memory: CPU의 작업공간

각 IO Device마다 Controller가 붙어있어 각 IO 디바이스를 전담하는 CPU 역할을 함
-> 속도차를 극복하기 위함
CPU 역할은 메모리에서 인트럭션을 하나씩 읽어서 실행하는 것일 뿐
CPU 안에는 메모리보다 더 빠른 저장공간인 레지스터가 있음
인터럽트 라인을 통해, IO 디바이스 

CPU는 IO 디바이스에 직접 접근하지 않고, 메모리에 있는 인트랙션만 처리하게 되어있음
디스크 컨트롤러에게 특정 데이터를 읽어오라고 시키게됨 -> 데이터처리/입력이 완료되면 

프로그램이 무한루프를 돌면서 CPU를 독점하는 경우를 막기 위해 타이머를 배치함
타이머에 세팅된 시간동안만 프로그램이 CPU를 사용하지만, 그 이후에는 타이머가 CPU에게 인터럽트를 걸게됨 -> 하드웨어를 통해 강제로 CPU 제어권을 사용자로부터 빼앗을 수 있게 함
타임 쉐어링. 시분할 을 기반으로 다음 프로그램에게 CPU를 넘겨주게됨. RR

CPU는 인스트랙션 처리, 인터럽트 라인 확인을 반복하며 동작한다.


mode bit
- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 ㅜ이한 보안장치
역할: 메모리 접근, IO디바이스 접근, 등 권한을 제한하기 위해 존재함 (보안상의 목적, 특권명령 - 동작 수행시 하드웨어적으로 검증을 진행함)
0 : 커널모드 - 운영체제가 CPU에서 실행중임
1 : 사용자모드 - 사용자 프로그램이 CPU에서 실행중인 경우

타이머
- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
- 타이머는 매 클럭 틱마다 1씩 감소
- 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 TimeSharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

I/O DeivceController
- 각 IO 장치를 관리하는 일종의 작은 CPU
- 제어 정보를 위해 Control Register, Status Register를 가짐
- Device Controller는 I/O가 끝낫을 경우 Interrupt로 CPU에 그 사실을 알림
- MemoryController도 존재함 <- CPU와 DMA가 동시에 메모리에 접근하는 것을 방지하기 위해 존재
- 참고로 IO 명령은 모두 특권 명령

DMA Controller (Direct Memory Access)
- IO 장치 인터럽트로 인한 CPU 성능 저하를 막기 위해, DMA가 IO Buffer에 있는 결과를 메모리에 전달하는 역할만 책임을 분리함
- 

인터럽트
- 보통 하드웨어 인터럽트를 말함
- Trap은 소프트웨어 인터럽트를 의미함
    - Exception: 프로그램이 오류를 범한 경우
    - SystemCall: 프로그램이 커널 함수를 호출하는 경우
- 현대의 운영체제는 인터럽트에 의해 구동됨.
    - 인터럽트가 걸리는 상황이 아니라면 운영체제가 CPU에서 동작할 일이 없음

인터럽트 벡터
- 해당 인터럽트의 처리 루틴 주소를 가지고 있음
인터럽트 처리 루틴
- 해당 인터럽트를 처리하는 커널 함수

시스템 콜
- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
    - 예. 운영체제에게 IO 요청을 하는 것
- Trap(소프트웨어 인터럽트)을 사용하여 인터럽트 벡터의 특정 위치로 이동
- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
- 올바른 IO 요청인지 확인후 IO 수행
- IO 완료시 제어권을 시스템콜 다음 명령으로 옮김

630


Sync
- IO 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감

Async
- IO가 시작된 후 입출력 작업이 끝나기를 기다리지않고 제어가 사용자 프로그램에 즉시 넘어감 


저장장치 계층 구조
- 상위 계층일수록 가격이 비싸지만 속도가 빠름, 휘발생 여부도 특징
Registers
Cache Memory
Main Memory
Magnetic Disk
Optical Disk
Magnetic Tape

Primiary: CPU가 직접 접근할 수 있는 것. 바이트 단위로 접근이 가능해아함 (Executable)
Secondary: 하드디스크 같은 경우 섹터 단위로 접근이 가능하기 때문에 Executable 하지 않음



