## 간단 정리

설명 드리기 앞서 말하고 싶은 것
1. Blocking-Sync가 비슷하고, NonBlocking-Async가 비슷하지만, Blocking/NonBlocking과 Sync/Async이 매트릭스 그림에서 각각 다른 축에 자리잡는 데는 이유가 있습니다. 두 그룹은 관심사가 다르다라는걸 기억하셨으면 좋겠습니다.!
2. 언어에 따라서는 Blocking / Non-Blocking 개념이 쓰이지 않는 언어들도 있기 때문에, 이 부분들은 공부하시는 언어에 해당 내용이 존재하는 개념인지를 먼저 찾아봐야합니다. 일반적으로  Blocking / Non-Blocking 개념이 쓰이지 않는 언어들에서는 **동기는 Blocking과 결합된 개념**으로, **비동기는 Non-Blocking과 결합된 개념**으로 생각하시면 편합니다.
3. Blocking NonBlocking을 말할때 꼭 I/O를 생각하시면 좋을듯 합니다. I/O는 Kernel Level에서 만 수행할 수 있는데 따라서 Process(thread)는 I/O를 수행하기 위해서 Kernel을 호출해야 한다고 합니다. 왜 I/O를 생각해야할까요? I/O가 일어날때 Blocking NonBlocking의 개념이 적용되기 떄문입니다.
> 제가 iOS프로그래머이다보니, 현재는 이에 관련된 개념만 다루고 있습니다. **iOS프로그래밍**에서는 blocking/non-blocking에 대한 개념이 따로 있지않고, **async는  non-blocking으로만** 다루고, **sync는 blocking으로만** 다루고 있습니다.


⭐ Blocking / Non-Blocking, Sync, ASync 간단 정리
- 동기 vs 비동기 : **요청한 작업에 대해 완료 여부를 따져** 순차대로 처리할지 순차적으로 처리하지 않을지라고 할 수 있습니다. 
- 블로킹 vs 논블로킹 : 처리되어야 하는 (하나의) 작업이, **전체적인 작업 '흐름'을 막느냐 안막느냐**에 대한 관점 주로 파일의 입출력을 다룰 때 흔히 볼 수 있다. 네트워크에서도 흔히 볼 수 있는데, 예를들어 소켓의 read와 send를 생각하면 될 것이다.
동기/비동기는 요청한 작업에 대해 완료 여부를 신경 써서 작업을 순차적으로 수행할지 아닌지에 대한 관점이고,블로킹/논블록킹은 단어 그대로 현재 작업이 block(차단, 대기) 되느냐 아니냐에 따라 다른 작업을 수행할 수 있는지에 대한 관점이다.

## Synchronous/Asynchronous

### Synchronous/Asynchronous 정의
⭐단어 뜻에서 생각해보자!
Synchronous의 Syn는 그리스어로 '함께'이란 뜻이고 chrono는 '시간'이라는 뜻이라고 합니다.
1. Synchronous는 작업 시간을 함께 맞춰서 실행한다 라는 뜻으로 해석되는데,작업을 맞춰 실행한다는 말은 **요청한 작업에 대해 완료 여부를 따져** 순차대로 처리하는 것을 말합니다. 
2. Asynchronous는 앞에 A라는 접두사가 붙어 부정하는 형태입니다. 동기와 반대로 **요청한 작업에 대해 완료 여부를 따지지 않기** 때문에 자신의 다음 작업을 그대로 수행하게 됩니다.

⭐ 어떤 차이가 있을까?
**Sync와 Async의 차이는 호출된 함수의 종료를 호출한 함수가 처리(A가 처리하는 Sync)하느냐, 호출된 함수가 처리하느냐(B의 결과를 콜백으로 B가 직접 처리하는 Async)의 차이**이다.  
(즉, 결과를 돌려주었을 때 순서와 결과에 관심이 있는지 없는지로 판단할 수 있다. )
1. Sync는 A 함수가 B함수를 호출할 때, B함수의 결과를 A함수가 처리하는 것이다. 작업 완료 후 리턴을 기다리는 것 단. Nonblocking과 합쳐지면 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경 쓰게 될 수 있다.
2. 반면에 Async는 B함수의 결과를 콜백으로 B함수가 직접 처리하는 것을 의미한다.  호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

> **Synchronous/Asynchronous는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사**다.

쉽게 말해 동기는 작업 A가 완료되어야 다음 작업을 수행하고, 비동기는 작업 A의 완료 여부를 따지지 않고 바로 다음 작업을 수행하는 것이다.
(완료된 응답을 받고 실행할지 아니면 완료된 응답을 받지 않아도 다음 차례로 넘어갈지 하는것)

## Blocking/Non-blocking

### Blocking/Non-blocking이란?
⭐ 단어의 뜻에서 생각해보자!
블로킹과 논블록킹은 단어에서 알 수 있듯이 다른 요청의 작업을 처리하기 위해 현재 작업을 block(차단, 대기) 하냐 안하냐의 유무를 나타내는 프로세스의 실행 방식입니다.

동기/비동기가 전체적인 작업에 대한 순차적인 흐름 유무라면, 블로킹/논블로킹은 전체적인 작업의 **흐름 자체를 막냐 안 막냐**로 볼 수 있는 것이다. 예를 들어, 파일을 읽는 작업이 있을 때, 블로킹 방식으로 읽으면 파일을 다 읽을 때까지 대기하고, 논블로킹 방식으로 읽으면 파일을 다 읽지 않아도 다른 작업을 할 수 있습니다.

⭐ 어떤 차이가 있을까?
Blocking과 Non-blocking은 호출된 함수가 호출한 함수에게 **제어권을 바로 주느냐 아니냐**에서 차이가 있습니다. Blocking / Non-Blocking**은 호출되는 **함수가 바로 리턴하느냐 마느냐가 중요한 개념** 입니다.
  **1) Blocking** - 호출된 함수가 즉시 리턴하지 않고 제어권을 주지 않는다
  **2) Non-Blocking** - 즉시 리턴을 통해 제어권을 넘겨준다!
호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.

그렇지 않고 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking이다.

> **Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사**다. Sync/Async는 결과를 호출하는 함수가 신경쓰냐 아니냐의 여부 차이!

## 조합

### **Blocking / Sync**
1. Process(Thread)가 Kernel에게 I/O를 요청한다.
    - Process는 작업을 중단한 채 대기한다. (Kernel에게 응답을 받기 전까지 다른 작업 못한다)
2. Kernel이 I/O 작업을 완료하면 결과를 반환한다.

blocking은 호출된 함수가 제어권을 넘겨주지 않고 , sync는 호출하는 함수가 결과 처리에 관심을 두고 결과를 받을떄까지 기다리는 구조입니다.
```
Blocking인 만큼 Kernel의 작업이 끝나기 전에는 절대 제어권을 Application에 주지 않는다. 그리고 Sync인 만큼 Kernel에서 작업한 결과물이 ❤️라고 치면, 이 결과 ❤️에 대한 업무를 **바로 Application에서 처리한다.**
```

특징
- I/O 작업이 진행되는 동안 User Process는 자신의 작업을 중단한 채 대기함으로 리소스 낭비가 심합니다. (I/O 작업이 CPU 자원을 거의 쓰지 않기 때문)
> Blocking I/O와 Synchronous I/O에서 리소스 낭비가 심한 이유는 대기 시간 때문입니다. 이러한 작업들은 I/O 작업의 완료를 기다리면서 해당 작업을 수행하는 프로세스나 스레드가 대기 상태에 있게 됩니다.

- 여러 클라이언트가 접속하는 서버를 Blocking 방식으로 구현한 경우 요청 마다 Thread가 생성되는데 여러가지의 문제점이 생기게 됩니다.
	- Thread가 매우 많아짐 → 콘텍스트 스위칭 횟수가 증가 **⇒ 비효율적 동작 방식** (많은 스레드가 동시에 실행되면 콘텍스트 스위칭 비용이 증가합니다.) 콘텍스트 스위칭은 CPU가 한 작업에서 다른 작업으로 전환될 때 발생하는데, 스레드가 많으면 이 비용이 더 높아지게 됩니다. 이로 인해 전체 시스템 성능이 감소할 수 있습니다
	- 많은 스레드가 동일한 자원에 접근할 때, deadlock이나 경합 조건과 같은 병행성 문제가 발생할 수 있습니다. 이는 스레드 간의 상호 작용에서 문제가 발생할 수 있는데, 이를 관리하려면 더 복잡한 동기화 메커니즘이 필요합니다.

> 콘텍스트 스위칭(Context Switching)은 CPU가 현재 실행 중인 프로세스나 스레드를 중단하고 다른 프로세스나 스레드로 전환하는 과정을 말합니다. 콘텍스트는 현재 실행 중인 프로세스나 스레드의 상태 정보를 나타내며, 이 정보는 CPU 레지스터 값, 프로그램 카운터, 스택 포인터 등을 포함합니다.

**Non-Blocking / Sync**

1. User Process가 Kernel에게 I/O를 요청한다.
2. Kernel은 바로 **EWOULDBLOCK**을 반환한다.
3. User Process는 그동안 다른 작업을 진행한다. **진행 중간에 Kernel에 I/O가 완료되었는지 확인한다.**
4. User Process가 확인했을 때 Kernel의 I/O가 끝난 경우 데이터를 복사해서 받아온다. 이때, 데이터는 Kernel이 가지고 있는 메모리에 적재되어 있으므로, Memory 간 복사로 I/O보다 훨씬 빠른 속도로 data를 받아올 수 있다.

다음걸 실행하고 싶고 제어권도 있지만  Sync이기떄문에 호출한 함수가 결과를 계속 신경써야 하고 전체 결과가(Ok사인) 오지 않아 실행 불가

### **Blocking / Async**

1. User Process는 Kernel에 I/O를 요청한다.
2. Kernel은 **EWOULDBLOCK**을 반환한다.
3. User Process는 select() 함수를 수행하며 I/O가 끝날 때까지 대기한다. **(Block)**
4. Kernel은 I/O가 끝나면 User Process에 데이터 사용이 가능함을 알린다.
5. 해당 알림을 받은 User Process는 Block을 풀고 데이터를 복사해서 받아온다

#### **어디서 blocking/async를 쓸까?**
일단 설명하기 앞서 **Blocking & Async는 어차피 다른 일을 못하니 일부러 사용하는 경우는 없다**고 합니다. 블로킹 + 비동기 코드 패턴은 특별한 경우에 사용될 수 있고, 주로 피해야 하는 패턴으로 간주됩니다.

결국 블로킹을 하면 비동기를 한다하더라도 다음 실행 순서로 넘어가지 않기 때문에 비동기의 장점을 살리지 못합니다.
비동기 코드를 사용하는 주된 목적은 I/O 바운드 작업에서 발생하는 대기 시간을 최소화하고, 다른 작업을 수행하는 동안에도 CPU를 효율적으로 활용하는 것입니다. 블로킹 코드를 도입하면 이러한 이점이 상쇄될 수 있습니다.

그러나 몇 가지 특수한 상황에서 블로킹 + 비동기 패턴이 유용할 수 있습니다. 
1. 기존의 동기 코드를 비동기 시스템에 통합할 때, 전체 코드를 비동기로 변경하기 어려울 때 블로킹 코드를 사용하여 특정 부분만 동기적으로 처리할 수 있습니다. 
2. 몇몇 외부 라이브러리가 블로킹 API를 제공하는 경우, 해당 라이브러리를 사용해야 할 때 블로킹 + 비동기 패턴을 고려할 수 있습니다.

다만 이러한 경우에도 주의가 필요하며, 블로킹 부분이 프로그램의 전반적인 성능에 미치는 영향을 고려해야 합니다. 만약 가능하다면 비동기 코드를 계속 사용하고, 특정 부분에서만 블로킹 코드를 적용하는 것이 좋습니다.

Blocking-Async는 별로 이점이 없어서 일부러 이 방식을 사용할 필요가 없기는 한데, 의도하지 않게 Blocking-Async로 동작하는 경우가 있다고 합니다.. 원래는 NonBlocking-Async를 추구하다가 의도와는 다르게 실제로는 Blocking-Async가 되어버리는 경우라고 하는데 그것은 바로..

**Blocking-Async의 대표적인 케이스가 Node.js와 MySQL의 조합**이라고 합니다.

Node.js 쪽에서 callback 지옥을 헤치면서 Async로 전진해와도, 결국 DB 작업 호출 시에는 MySQL에서 제공하는 드라이버를 호출하게 되는데, 이 드라이버가 Blocking 방식이라고 한다. 

이건 사실 Node.js 뿐아니라 Java의 JDBC도 마찬가지다. 다만 Node.js가 싱글 쓰레드 루프 기반이라 멀티 쓰레드 기반인 Java의 Servlet 컨테이너보다 문제가 더 두드러져 보일 뿐, Blocking-Async라는 근본 원인은 같다.

그래서 Blocking-Async는 이렇게 정리해도 좋을 것 같다.

> Blocking-Async는 별다른 장점이 없어서 일부러 사용할 필요는 없지만, 
> 
> **NonBlocking-Async 방식을 쓰는데 그 과정 중에 하나라도 Blocking으로 동작하는 놈이 포함되어 있다면 의도하지 않게 Blocking-Async로 동작**할 수 있다.

**Non-Blocking / Async**
1. User Process는 Kernel에 I/O를 요청한다.
2. Kernel은 I/O 작업의 완료와 무관하게 즉시 응답해 준다.
3. User Process는 다른 작업을 수행한다. **(I/O 작업이 끝났는지 확인하지 않음)**
4. Kernel은 I/O가 끝나면 User Process에 알려준다. 데이터를 복사해서 받아온다.


