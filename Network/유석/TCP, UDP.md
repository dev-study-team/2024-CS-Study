# 📚 TCP/IP(Transmission Control Protocol)란?
TCP/IP는 하나의 프로토콜이 아닌 TCP와 IP를 합쳐서 부르는 말입니다. 또한 TCP/IP를 사용하겠다는 것은 IP 주소 체계를 따르고 IP Routing을 이용해 목적지에 도달하며 TCP의 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 것을 의미한다.
즉, TCP/IP를 말한다는 것은 **송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고 그 데이터가 제대로 갔는지, 너무 빠르지 않는지, 제대로 받았다고 연락은 오는지**에 대한 이야기를 하는 것이다.

![](https://velog.velcdn.com/images/gkdlzjaqor92/post/77611c4e-23e7-4c0f-84b3-2b9e5d4d46dd/image.png)


## TCP 특징

-연결 지향 방식으로 패킷 교환 방식을 사용한다(가상 회선 방식이 아님).
- 신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 데이터의 순차 전송을 보장한다.
- Flow Control (흐름 제어)
- Congestion Control (혼잡 제어)
- Error Detection (오류 감지)
- UDP보다 속도가 느리다.


TCP가 연결 지향 방식이라는 것은 패킷을 전송하기 위한 논리적 경로를 배정한다는 말이다. 그리고 3-way handshaking과정은 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서
세션을 수립하는 과정을 의미한다. 신뢰성을 보장하기 위해 3-way handshaking의 과정도 사용하는 것이고, 데이터의 흐름제어나 혼잡 제어와 같은 기능도 한다. 하지만 이러한 기능때문에 UDP보다 속도가 느리게 된다. (이러한 기능은 CPU를 사용하기 때문에 속도에 영향을 주는 것이다.)
그렇기에 TCP는 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜로 예를 들면 파일 전송과 같은 경우에 사용된다.

## TCP 서버 특징
- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)

# 📚 흐름제어 (Flow Control)
- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실될 수 있으며, 만약 손실된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생한다.
- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야 한다.

## 📒 Stop and Wait
매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법이다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.
![](https://velog.velcdn.com/images/gkdlzjaqor92/post/414cfa35-65e4-49d3-8bc0-34eb881bc867/image.png)

## 📒 Sliding Window
수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.

- 윈도우 크기

최초의 윈도우 크기는 호스트들의 '3-way Handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다. 윈도우 크기는 수신 측에서 송신 측으로 확인응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다. 즉, 윈도우는 메모리 버퍼의 일정영역이라고 생각하면 된다.

- 동작 방식
> 윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.

![](https://velog.velcdn.com/images/gkdlzjaqor92/post/6476e969-2983-4d25-af3b-9a079fb3e76e/image.png)

1. 최초로 수신자는 윈도우 사이즈를 7로 정한다.
2. 송신자는 수신자의 ACK를 받기 전까지 데이터를 보낸다.
3. 수신자는 ACK를 송신자에게 보내면, 슬라이딩 윈도우 사이즈를 충족할 수 있게끔 윈도우를 옆으로 옮긴다.
4. 이후 데이터를 다 받을 때까지 위 과정을 반복한다.

- 재전송

> 송신 측은 일정 시간동안 수신 측으로부터 확인 응답(ACK)을 받지 못하면, 패킷을 재전송한다.
만약, 송신 측에서 재전송을 했는데 패킷이 소실된 경우가 아니라 수신 측의 버퍼에 남는 공간이 없는 경우면 문제가 생긴다. 이를 해결하기 위해 송신 측은 해결 응답(ACK)을 보내면서 남은 버퍼의 크기(윈도우 크기)도 함께 보내준다.

# 📚 혼잡 제어

데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다. 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데, 이것을 '혼잡 제어'라 한다.

> 흐름 제어는 송,수신 측 사이의 패킷 수를 제어하는 기능이라 할 수 있으며, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능이다.


## 📘 AMID (Additive Increase/Multicative Decrease)

- 우리 말로 직역하면 합 증가/곱 감소 방식이다. 
- AMID 방식은 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜 가면서 전송한다. 
- 만약, 전송에 실패하면 윈도우의 크기를 반으로 줄인다.
- 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.


![](https://velog.velcdn.com/images/gkdlzjaqor92/post/00858dc5-285d-43b9-8790-f39cea3db4f9/image.png)

## 📘 Slow Start (느린 시작)

위 AMID 방식은 윈도우 크기를 선형적으로 증가시키기 때문에, 제대로 된 속도가 나오기까지 시간이 오래 걸린다. 반면 Slow Start는 윈도우의 크기를 1,2,4,8... 과 같이 제곱수로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식이다.

이 방식은 보낸 데이터의 ACK가 도착할 때마다, 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.

![](https://velog.velcdn.com/images/gkdlzjaqor92/post/538b7eae-08cd-4ad4-aa46-980f8777a2ae/image.png)

## 📘 빠른 재전송 (Fast Retransmit)

패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들일 순서대로 도착하지 않는 경우가 생길 수 있다. 이런 상황이 발생했을 때 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다.
그리고 이런 중복 ACK를 3개 받으면 재전송이 이루어진다. 송신 측은 자신이 설정한 타임아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.

## 📘 빠른 회복 (Fast Recovery)

빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 혼잡 상황을 한번 겪고 나서부터는 순수한 AMID 방식으로 동작하게 된다.


# 📚 UDP(User Datagram Protocol)란?
데이터를 데이터그램 단위로 처리하는 프로토콜이다. UDP는 TCP와 달리 비연결형 프로토콜이다. 즉, 연결을 위해 할당되는 논리적인 경로가 없는데, 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되는데 이렇게 데이터를 서로 다른 경로로 독립적으로 처리하는 것을 UDP라고 한다.

![](https://velog.velcdn.com/images/gkdlzjaqor92/post/05646f75-5111-4f95-962e-d202e432c49b/image.png)


## UDP 특징

- 비연결형 서비스로 데이터그램 방식을 제공한다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.

UDP는 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다. 서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 재조립 하거나 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만 신뢰성있는 데이터의 전송을 보장하지는 못한다. 그렇기 때문에 **신뢰성보다는 연속성이 중요한 서비스** 예를 들면 실시간 서비스(streaming)에 자주 사용된다.

## UDP 서버 특징
- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

# TCP/UDP 비교
![](https://velog.velcdn.com/images/gkdlzjaqor92/post/89940fc1-0911-49cd-a135-6f260234032f/image.png)


### References
https://mangkyu.tistory.com/15
https://steady-coding.tistory.com/507
https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html
https://aws-hyoh.tistory.com/entry/TCPIP-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
